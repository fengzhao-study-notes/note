##### 1、prefork（非线程）

工作方式：
	当Apache服务器启动后，mpm_prefork模块会预先创建多个子进程(默认为5个)，每个子进程只有一个线程，当接收到客户端的请求后，mpm_prefork模块再将请求转交给子进程处理，并且每个子进程同时只能用于处理单个请求。如果当前的请求数将超过预先创建的子进程数时，mpm_prefork模块就会创建新的子进程来处理额外的请求。Apache总是试图保持一些备用的或者是空闲的子进程用于迎接即将到来的请求。这样客户端的请求就不需要在接收 后等候子进程的产生由于在mpm_prefork模块中，每个请求对应一个子进程，因此其占用的系统资源相对其他两种模块而言较多。不过mpm_prefork模块的优点在于它的每个子进程都会独立处理对应的单个请求，这样，如果其中一个请求出现问题就不 会影响到其他请求
可调节参数：

```shell
<IfModule mpm_prefork_module>
# 启动时默认开启的子进程数
StartServers 10
# 最小闲置子进程数
MinSpareServers 8
# 最大闲置子进程数
MaxSpareServers 10
# 运行同时的最大请求数量
MaxRequestWorkers 250
# 每个子进程可处理的请求数
MaxConnectionsPerChild 500
</IfModule>
```
?	主进程在创建了StartServers个子进程后,为了满足MinSpareServer的设置需求,会先创建一个进程,等待一秒,创建二个进程,再等待一秒,创建四个进程....以几何数增加创建的进程,最多达到每秒创建32个,直到满足MinSpareServer的设置(可以看到以下的MinSpareServer为5),这就是预派生(Prefork)的由来,这样不必等到有请求到来时才花时间创建新的进程,提高了系统响应速度以增加性能.

##### 2、worker（多线程多进程）
?	使用了多进程和多线程的混合模式，worker模式也同样会先预派生一些子进程，然后 每个子进程创建一些线程，同时包括一个监听线程，每个请求过来会被分配到一个线程来服务。线程比起进程会更轻量，因为线程是通过共享父进程的内存空间，因此，内存的占用会减少一些，在高并发的场景下会比prefork有更多可用的线程，表现会更优秀一些；另外，如果一个线程出现了问题也会导致同一进程下的线程出现问题，如果是多个线程出现问题，也只是影响Apache的一部分，而不是全部。由于用到多进程多线程，需要考虑到线程的安全了，在使用keep-alive长连接的时候，某个线程会一直被占用，即使中间没有请求，需要等待到超时才会被释放（该问题在prefork模式下也存 在）
可调节参数：

```shell
# event MPM
<IfModule mpm_worker_module>
# 服务器启动时建立的子进程数量
StartServers 3 
# 空闲子进程的最小数量
MinSpareThreads 75 
# 空闲子进程的最小数量
MaxSpareThreads 250 
# 每个子进程产生的线程数量
ThreadsPerChild 25 
# 限定服务器同一时间内客户端最大接入的请求数量，默认是150；任何超过了该限制的请求都要进入等待队列，一旦一个个连接被释放，队列中的请求才将得到服务。
MaxRequestWorkers 400 
# 每个子进程在其生命周期内允许最大的请求数量，如果请求总数已经达到这个数值，子进程将会结束，如果设置为0，子进程将永远不会结束。将该值设置为非0值，可以防止运行PHP导致的内存泄露
MaxRequestsPerChild 0  
</IfModule>
```
##### 3、event
?	 IO多路复用，基于事件驱动的模型。一个进程处理多个套接字，一个进程同时处理多个请求
是Apache最新的工作模式，是worker模式的变种，它把服务进程从连接中分离出来，一worker模式不同的是在于它解决了keep-alive长连接的时候占用线程资源被浪费的问题，在event工作模式中，会有一些专门的线程用来管理这些keep-alive类型的线程，当有真实请求过来的时候，将请求传递给服务器的线程，执行完毕后，又允许它释放。这增强了在高并发场景下的请求处理。这样，一个线程就能处理几个请求了，实现了异步非阻塞。eventMPM在遇到某些不兼容的模块时，会失效，将会回退到worker模式，一个工作线程处理一个请求。官方自带的模块，全部是支持event MPM 的
可调参数:

```shell
# event MPM
<IfModule mpm_worker_module>
# 服务器启动时建立的子进程数量
StartServers 3 
# 空闲子进程的最小数量
MinSpareThreads 75 
# 空闲子进程的最小数量
MaxSpareThreads 250 
# 每个子进程产生的线程数量
ThreadsPerChild 25 
# 限定服务器同一时间内客户端最大接入的请求数量，默认是150；任何超过了该限制的请求都要进入等待队列，一旦一个个连接被释放，队列中的请求才将得到服务。
MaxRequestWorkers 400 
# 每个子进程在其生命周期内允许最大的请求数量，如果请求总数已经达到这个数值，子进程将会结束，如果设置为0，子进程将永远不会结束。将该值设置为非0值，可以防止运行PHP导致的内存泄露 
MaxRequestsPerChild 0 
</IfModule>
```