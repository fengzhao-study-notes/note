#### 数据库三大范式

关系数据库常见的范式有：第一范式（1NF)、第二范式（2NF)、第三范式（3NF)、第四范式（4NF)、第五范式（5NF)、BCNF、常见的是前3种范式

1. 第一范式（1NF):指的是关系数据库的每一列都是不可分割的基本数据项，同一列中不能有多个值。保证了数据的不重复性。数据库表中不能出现重复记录，每个字段是原子性的不能再分
2. 第二范式（2NF):要满足第二范式必须先满足第一范式。在第二范式中，要求数据库表中的每个行必须可以被唯一的区分，为实现区分通常将表的第一个或多个属性作为行的唯一标识，这个标识称为主键。在第二范式中，要求行的列值完全依赖于主关键字。所有非主键字段完全依赖主键，不能产生部分依赖
3. 第三范式要求数据库中的表的非主键列之间不能有依赖。也就是说，第三范式主要用于减少数据冗余。非主键字段不能传递依赖于主键字段，不要产生传递依赖

简言之：

+ 第一范式：有主键，具有原子性，字段不可分割
+ 第二范式：完全依赖，没有部分依赖
+ 第三范式：没有传递依赖

数据库设计尽量遵循三范式，但是还是根据实际情况进行取舍，有时可能会拿冗余换速度，最终用目的要满足客户需求。

#### 存储引擎

- **MyISAM存储引擎**
  MyISAM存储引擎是MySQL最常用的引擎。
  它管理的表具有以下特征：

  - 使用三个文件表示每个表：
    - 格式文件 — 存储表结构的定义（mytable.frm）
    - 数据文件 — 存储表行的内容（mytable.MYD）
    - 索引文件 — 存储表上索引（mytable.MYI）

  - 灵活的AUTO_INCREMENT字段处理
  - 可被转换为压缩、只读表来节省空间

- **InnoDB存储引擎**

  是MySQL从5.5版本的缺省引擎。
  它管理的表具有下列主要特征：

1. 每个InnoDB表在数据库目录中以.frm格式文件表示
2. InnoDB表空间tablespace被用于存储表的内容
3. 提供一组用来记录事务性活动的日志文件
4. 用COMMIT(提交)、SAVEPOINT及ROLLBACK(回滚)支持事务处理
5. 提供全ACID兼容
6. 在MySQL服务器崩溃后提供自动恢复
7. 多版本（MVCC）和行级锁定
8. 支持外键及引用的完整性，包括级联删除和更新

#### 四个隔离级别
- READ UNCOMMITTED（读未提交数据）：允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。
- READ COMMITTED（读已提交数据）：只允许事务读取已经被其他事务提交的变更数据，可避免脏读，仍会出现不可重复读和幻读问题。
- REPEATABLE READ（可重复读）：确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。
- SERIALIZABLE（序列化/串行化）：它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。

#### 数据库事务
事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。
(数据库引擎innoDB是支持事务的(默认每一条sql语句为一个事务)，MyISAM不支持事务。)
在关系数据库中,一个事务可以是一条SQL语句、一组SQL语句或整个程序。
开始事务：BEGIN TRANSACTION  
提交事务：COMMIT TRANSACTION  
回滚事务：ROLLBACK TRANSACTION   

事务的四大属性:ACID
1. 原子性（Atomicity）: 事务开始后的所有操作，要么全部做完，要么全部不做，不可以停滞在中间环节。事务执行过程中若出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。事务是一个不可分割的整体。
2. 一致性（Consistency）: 事务开始前和结束后，数据库的完整性约束没有被破坏。
3. 隔离性（Isolation）: 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。（一个事务内部的操作及正在操作的数据必须封装起来，不被其它企图进行修改的事务看到）
4. 持久性（Durability）: 事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。
    原子性是事务隔离的基础，隔离性和持久性是手段，最终目的是为了保持数据的一致性。

#### 事务的并发问题
1. 丢失更新：如果两个事务A和B都要更新数据库一个字段，并同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务A更新会被后提交事务B的更新给覆盖掉，这种情况事务A的更新就被覆盖掉了、丢失了。
2. 脏读：事务A读取了事务B更新(但未提交)的数据，然后B回滚操作，那么A读取到的数据是脏数据；
3. 不可重复读：事务 A 中多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
4. 幻读：第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。
    小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。